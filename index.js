// index.js â€” Parche ESM-safe + rutas tiempo actualizadas, sin cambiar tu flujo
const axios = require("axios");
const fetch = require("node-fetch");
const chalk = require("chalk");
const yargs = require("yargs/yargs");
const os = require("os");
const path = require("path");
const { join } = path;
const figlet = require("figlet");
const fs = require("fs");
const { readdirSync, statSync, unlinkSync } = fs;
const readline = require("readline");
const pino = require("pino");
const { isOwner, getPrefix, allowedPrefixes } = require("./config");
const { handleCommand } = require("./main");
const PORT = process.env.PORT || 3000;

// ===================== util canal reenviado =====================
let canalId = ["120363266665814365@newsletter"];
let canalNombre = ["ğŸª¼ Cortana Ultra 2.0 BOT ğŸª¼"];

function setupConnection(conn) {
  conn.sendMessage2 = async (chat, content, m, options = {}) => {
    const firstChannel = { id: canalId[0], nombre: canalNombre[0] };
    if (content.sticker) {
      return conn.sendMessage(chat, { sticker: content.sticker }, { quoted: m, ...options });
    }
    const messageOptions = {
      ...content,
      mentions: content.mentions || options.mentions || [],
      contextInfo: {
        ...(content.contextInfo || {}),
        forwardedNewsletterMessageInfo: {
          newsletterJid: firstChannel.id,
          serverMessageId: "",
          newsletterName: firstChannel.nombre,
        },
        forwardingScore: 9999999,
        isForwarded: true,
        mentionedJid: content.mentions || options.mentions || [],
      },
    };
    return conn.sendMessage(chat, messageOptions, {
      quoted: m,
      ephemeralExpiration: 86400000,
      disappearingMessagesInChat: 86400000,
      ...options,
    });
  };
}

// ===================== helpers LUMI =====================
async function getPrompt() {
  try {
    const res = await fetch("https://raw.githubusercontent.com/elrebelde21/LoliBot-MD/main/src/text-chatgpt.txt");
    return await res.text();
  } catch {
    return "Eres un asistente inteligente";
  }
}
function cleanResponse(text) {
  if (!text) return "";
  return text
    .replace(/Maaf, terjadi kesalahan saat memproses permintaan Anda/g, "")
    .replace(/Generated by BLACKBOX\.AI.*?https:\/\/www\.blackbox\.ai/g, "")
    .replace(/and for API requests replace https:\/\/www\.blackbox\.ai with https:\/\/api\.blackbox\.ai/g, "")
    .trim();
}
async function luminaiQuery(q, user, prompt) {
  const { data } = await axios.post("https://luminai.my.id", {
    content: q,
    user: user,
    prompt: prompt,
    webSearchMode: true,
  });
  return data.result;
}
async function perplexityQuery(q, prompt) {
  const { data } = await axios.get("https://api.perplexity.ai/chat", {
    params: { query: encodeURIComponent(q), context: encodeURIComponent(prompt) },
  });
  return data.response;
}

// ===================== lista permitidos =====================
function isAllowedUser(sender) {
  const listaFile = "./lista.json";
  if (!fs.existsSync(listaFile)) return false;
  const lista = JSON.parse(fs.readFileSync(listaFile, "utf-8"));
  const num = sender.replace(/\D/g, "");
  return lista.includes(num);
}

// ===================== modos (no tocar tu lÃ³gica) =====================
const activosFile = "./activos.json";
function cargarModos() {
  if (!fs.existsSync(activosFile)) {
    fs.writeFileSync(activosFile, JSON.stringify({ modoPrivado: false, modoAdmins: {} }, null, 2));
  }
  return JSON.parse(fs.readFileSync(activosFile, "utf-8"));
}
function guardarModos(data) {
  fs.writeFileSync(activosFile, JSON.stringify(data, null, 2));
}
let modos = cargarModos();

// ===================== limpieza tmp =====================
global.opts = new Object(yargs(process.argv.slice(2)).exitProcess(false).parse());
async function clearTmp() {
  const tmp = [os.tmpdir(), join(__dirname, "./tmp")];
  const filename = [];
  tmp.forEach((dirname) => readdirSync(dirname).forEach((file) => filename.push(join(dirname, file))));
  return filename.map((file) => {
    const stats = statSync(file);
    if (stats.isFile() && Date.now() - stats.mtimeMs >= 1000 * 60 * 1) return unlinkSync(file);
    return false;
  });
}
if (!opts["test"]) {
  setInterval(async () => {
    if (opts["autocleartmp"]) try { clearTmp(); } catch (e) { console.error(e); }
  }, 60 * 1000);
}
setInterval(async () => {
  await clearTmp();
  console.log(chalk.cyanBright(`â•­â”â”€â”â”€â”â”€â‰ªğŸ”†â‰«â”€â”â”€â”â”€â”â•®\nâ”‚SE LIMPIO LA CARPETA TMP CORRECTAMENTE\nâ•°â”â”€â”â”€â”â”€â‰ªğŸ”†â‰«â”€â”â”€â”â”€â”â•¯`));
}, 1000 * 60 * 60);
// ===================== Carga de plugins con logs =====================
function loadPlugins() {
  const plugins = [];
  const pluginDir = path.join(__dirname, 'plugins');

  if (!fs.existsSync(pluginDir)) {
    console.log(chalk.yellow('âš ï¸ Carpeta "plugins" no existe.'));
    return plugins;
  }

  const files = fs.readdirSync(pluginDir).filter(f => f.endsWith('.js'));
  let ok = 0, fail = 0;

  for (const file of files) {
    const full = path.join(pluginDir, file);
    try {
      // limpiar cache para recargar limpio
      delete require.cache[require.resolve(full)];
      const mod = require(full);

      const cmds = Array.isArray(mod.command) ? mod.command : [];
      if (typeof mod === 'function' || cmds.length) {
        plugins.push(mod);
        ok++;
        console.log(
          chalk.green('âœ”ï¸'), chalk.white(file),
          cmds.length ? chalk.gray(`â†’ [${cmds.join(', ')}]`) : chalk.gray('(handler fn)')
        );
      } else {
        fail++;
        console.log(
          chalk.yellow('â€¢'), chalk.white(file),
          chalk.gray('â†’ export invÃ¡lido (se espera function o {command:[...]})')
        );
      }
    } catch (e) {
      fail++;
      console.log(chalk.red('âœ–ï¸'), chalk.white(file), chalk.red(`â†’ ${e.message}`));
    }
  }

  console.log(
    (fail ? chalk.yellow : chalk.green)(`ğŸ§© Plugins cargados: ${ok}/${files.length}`) +
    (fail ? chalk.yellow(` â€” fallos: ${fail}`) : '')
  );

  return plugins;
}
// ===================== arranque (parche ESM-safe) =====================
(async () => {
  const {
    default: makeWASocket,
    useMultiFileAuthState,
    fetchLatestBaileysVersion,
    makeCacheableSignalKeyStore,
    downloadContentFromMessage,
  } = await import("@whiskeysockets/baileys");

// â¬‡ï¸ INYECCIÃ“N GLOBAL PARA PLUGINS
  global.wa = { downloadContentFromMessage };

  const { state, saveCreds } = await useMultiFileAuthState("./sessions");

  // consola
  console.log(chalk.cyan(figlet.textSync("Azura Ultra Bot", { font: "Standard" })));
  console.log(chalk.green("\nâœ… Iniciando conexiÃ³n...\n"));
  console.log(chalk.yellow("ğŸ“¡ Â¿CÃ³mo deseas conectarte?\n"));
  console.log(chalk.green("  [1] ") + chalk.white("ğŸ“· Escanear cÃ³digo QR"));
  console.log(chalk.green("  [2] ") + chalk.white("ğŸ”‘ Ingresar cÃ³digo de 8 dÃ­gitos\n"));

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  const question = (text) => new Promise((resolve) => rl.question(text, resolve));

  let method = "1";
  if (!fs.existsSync("./sessions/creds.json")) {
    method = await question(chalk.magenta("ğŸ“ Ingresa tu nÃºmero (Ej: 5491168XXXX) "));
    if (!["1", "2"].includes(method)) {
      console.log(chalk.red("\nâŒ OpciÃ³n invÃ¡lida. Reinicia el bot y elige 1 o 2."));
      process.exit(1);
    }
  }

  async function startBot() {
    try {
      const { version } = await fetchLatestBaileysVersion();
      const socketSettings = {
        printQRInTerminal: method === "1",
        logger: pino({ level: "silent" }),
        auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "silent" })) },
        browser: method === "1" ? ["AzuraBot", "Safari", "1.0.0"] : ["Ubuntu", "Chrome", "20.0.04"],
      };

      const sock = makeWASocket(socketSettings);
      setupConnection(sock);

      // pairing 8 dÃ­gitos (sin tocar tu flujo)
      if (!fs.existsSync("./sessions/creds.json") && method === "2") {
        let phoneNumber = await question("ğŸ˜Fino vamos ayağŸ˜: ");
        phoneNumber = phoneNumber.replace(/\D/g, "");
        setTimeout(async () => {
          let code = await sock.requestPairingCode(phoneNumber);
          console.log(chalk.magenta("ğŸ”‘ CÃ³digo de vinculaciÃ³n: ") + chalk.yellow(code.match(/.{1,4}/g).join("-")));
        }, 2000);
      }

      // ---------- TUS BLOQUES MANTENIDOS (con ajustes mÃ­nimos) ----------

      if (opts["server"]) (await import("./server.js")).default(global.conn, PORT);

      // limpiar antidelete cada 30m
      const archivosAntidelete = ["./antidelete.json", "./antideletepri.json", "./gruposu.json", "./prisu.json"];
      function limpiarAntidelete() {
        for (const archivo of archivosAntidelete) {
          if (fs.existsSync(archivo)) {
            fs.writeFileSync(archivo, JSON.stringify({}, null, 2));
            console.log(`ğŸ§¹ Archivo limpiado: ${archivo}`);
          }
        }
      }
      setInterval(limpiarAntidelete, 30 * 60 * 1000);
      limpiarAntidelete();

      // === REVISIÃ“N AUTOMÃTICA DE GRUPOS (rutas nuevas) ===
      setInterval(async () => {
        try {
          const ahora = Date.now();

          // CERRAR
          const tiempoCerrarPath = path.resolve("./tiempogrupo2.json");
          if (fs.existsSync(tiempoCerrarPath)) {
            const tiempoCerrar = JSON.parse(fs.readFileSync(tiempoCerrarPath, "utf-8"));
            for (const groupId of Object.keys(tiempoCerrar)) {
              const t = tiempoCerrar[groupId];
              if (ahora >= t) {
                console.log(`â° Se cumpliÃ³ el tiempo para CERRAR el grupo: ${groupId}`);
                try {
                  await sock.groupSettingUpdate(groupId, "announcement");
                  await sock.sendMessage(groupId, { text: "ğŸ”’ El grupo ha sido cerrado automÃ¡ticamente. Solo admins pueden escribir." });
                } catch (e) {
                  console.error(`âŒ Error cerrando grupo ${groupId}:`, e);
                }
                delete tiempoCerrar[groupId];
                fs.writeFileSync(tiempoCerrarPath, JSON.stringify(tiempoCerrar, null, 2));
              }
            }
          }

          // ABRIR
          const tiempoAbrirPath = path.resolve("./tiempogrupo.json");
          if (fs.existsSync(tiempoAbrirPath)) {
            const tiempoAbrir = JSON.parse(fs.readFileSync(tiempoAbrirPath, "utf-8"));
            for (const groupId of Object.keys(tiempoAbrir)) {
              const t = tiempoAbrir[groupId];
              if (ahora >= t) {
                console.log(`â° Se cumpliÃ³ el tiempo para ABRIR el grupo: ${groupId}`);
                try {
                  await sock.groupSettingUpdate(groupId, "not_announcement");
                  await sock.sendMessage(groupId, { text: "ğŸ”“ El grupo ha sido abierto automÃ¡ticamente. Â¡Todos pueden escribir!" });
                } catch (e) {
                  console.error(`âŒ Error abriendo grupo ${groupId}:`, e);
                }
                delete tiempoAbrir[groupId];
                fs.writeFileSync(tiempoAbrirPath, JSON.stringify(tiempoAbrir, null, 2));
              }
            }
          }
        } catch (error) {
          console.error("âŒ Error en la revisiÃ³n automÃ¡tica de grupos:", error);
        }
      }, 5000);

      // ====== BIENVENIDA / DESPEDIDA + ANTIARABE (igual a tu lÃ³gica) ======
      sock.ev.on("group-participants.update", async (update) => {
        try {
          if (!update.id.endsWith("@g.us")) return;
          const activosPath = "./activos.json";
          let activos = {};
          if (fs.existsSync(activosPath)) activos = JSON.parse(fs.readFileSync(activosPath, "utf-8"));

          // --- antiarabe (igual) ---
          if (activos.antiarabe && activos.antiarabe[update.id]) {
            const disallowedPrefixes = ["20","212","213","216","218","222","224","249","252","253","269","961","962","963","964","965","966","967","968","970","971","972","973","974","975","976","980","992","998"];
            if (update.action === "add") {
              let groupMetadata = {};
              try { groupMetadata = await sock.groupMetadata(update.id); } catch (err) { console.error("Meta grupo:", err); }
              for (const participant of update.participants) {
                const phoneNumber = participant.split("@")[0];
                const isDisallowed = disallowedPrefixes.some((p) => phoneNumber.startsWith(p));
                if (isDisallowed) {
                  let bypass = false;
                  const info = groupMetadata.participants.find((p) => p.id === participant);
                  if (info && (info.admin === "admin" || info.admin === "superadmin")) bypass = true;
                  if (!bypass && !isOwner(participant)) {
                    await sock.sendMessage(update.id, {
                      text: `âš ï¸ @${phoneNumber} tiene un nÃºmero prohibido y serÃ¡ expulsado.`,
                      mentions: [participant],
                    });
                    try { await sock.groupParticipantsUpdate(update.id, [participant], "remove"); } catch (e) { console.error("Expulsar:", e); }
                  }
                }
              }
            }
          }

          // --- welcome/despedidas (igual) ---
          const welcomeActivo = activos.welcome?.[update.id];
          const despedidasActivo = activos.despedidas?.[update.id];
          if (!welcomeActivo && !despedidasActivo) return;

          const welcomePath = "./welcome.json";
          let customWelcomes = {};
          if (fs.existsSync(welcomePath)) customWelcomes = JSON.parse(fs.readFileSync(welcomePath, "utf-8"));

          const welcomeTexts = [
            "Â¡Bienvenido(a)! Cortana Ultra 2.0 Bot te recibe con los brazos abiertos ğŸ¤—âœ¨. Â¡Disfruta y comparte!",
            "Â¡Hola! cortana Ultra 2.0 Bot te abraza con alegrÃ­a ğŸ‰ğŸ¤–. Â¡PrepÃ¡rate para grandes aventuras!",
            "Â¡Saludos! cortana Ultra 2.0 Bot te da la bienvenida para que descubras ideas brillantes ğŸš€ğŸŒŸ.",
            "Â¡Bienvenido(a) al grupo! cortana Ultra 2.0 Bot te invita a explorar un mundo de posibilidades ğŸ¤©ğŸ’¡.",
            "Â¡QuÃ© alegrÃ­a verte! cortana Ultra 2.0 Bot te recibe y te hace sentir en casa ğŸ ğŸ’–.",
            "Â¡Hola! Gracias por unirte; cortana Ultra 2.0 Bot te saluda con entusiasmo ğŸŠğŸ˜Š.",
            "Â¡Bienvenido(a)! Cada nuevo miembro es una chispa de inspiraciÃ³n en Azura Ultra 2.0 Bot ğŸ”¥âœ¨.",
            "Â¡Saludos cordiales! cortana Ultra 2.0 Bot te envÃ­a un abrazo virtual ğŸ¤—ğŸ’™.",
            "Â¡Bienvenido(a)! Ãšnete a la experiencia cortana Ultra 2.0 Bot y comparte grandes ideas ğŸ‰ğŸŒˆ.",
            "Â¡Hola! cortana Ultra 2.0 Bot te da la bienvenida para vivir experiencias inolvidables ğŸš€âœ¨!",
          ];
          const farewellTexts = [
            "Â¡AdiÃ³s! cortana Ultra 2.0 Bot te despide con gratitud y te desea Ã©xitos en tus nuevos caminos ğŸ‘‹ğŸ’«.",
            "Hasta pronto, desde cortana Ultra 2.0 Bot te deseamos lo mejor y esperamos verte de nuevo ğŸŒŸğŸ™.",
            "Â¡Chao! cortana Ultra 2.0 Bot se despide, pero siempre tendrÃ¡s un lugar si decides regresar ğŸ¤—ğŸ’”.",
            "Nos despedimos con cariÃ±o; gracias por compartir momentos en cortana Ultra 2.0 Bot ğŸ â¤ï¸.",
            "Â¡AdiÃ³s, amigo(a)! cortana Ultra 2.0 Bot te manda un abrazo y te desea mucha suerte ğŸ¤ğŸŒŸ.",
            "Hasta luego, y gracias por haber sido parte de nuestra comunidad ğŸš€ğŸ’™.",
            "Chao, que tus futuros proyectos sean tan brillantes como tÃº ğŸŒŸâœ¨. Azura Ultra 2.0 Bot te recuerda siempre.",
            "Â¡Nos vemos! cortana Ultra 2.0 Bot te dice adiÃ³s con un corazÃ³n lleno de gratitud ğŸ¤—â¤ï¸.",
            "Â¡AdiÃ³s! Que tu camino estÃ© lleno de Ã©xitos, te lo desea cortana Ultra 2.0 Bot ğŸš€ğŸŒŸ.",
            "Hasta pronto, y gracias por haber compartido momentos inolvidables con cortana Ultra 2.0 Bot ğŸ‘‹ğŸ’–.",
          ];

          if (update.action === "add" && welcomeActivo) {
            for (const participant of update.participants) {
              const mention = `@${participant.split("@")[0]}`;
              const customMessage = customWelcomes[update.id];
              let profilePicUrl;
              try { profilePicUrl = await sock.profilePictureUrl(participant, "image"); }
              catch {
                try { profilePicUrl = await sock.profilePictureUrl(update.id, "image"); }
                catch { profilePicUrl = "https://cdn.dorratz.com/files/1741323171822.jpg"; }
              }
              if (customMessage) {
                await sock.sendMessage(update.id, { image: { url: profilePicUrl }, caption: `ğŸ‘‹ ${mention}\n\n${customMessage}`, mentions: [participant] });
              } else {
                const mensajeTexto = welcomeTexts[Math.floor(Math.random() * welcomeTexts.length)];
                const option = Math.random();
                if (option < 0.33) {
                  await sock.sendMessage(update.id, { image: { url: profilePicUrl }, caption: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`, mentions: [participant] });
                } else if (option < 0.66) {
                  let groupDesc = "";
                  try {
                    const metadata = await sock.groupMetadata(update.id);
                    groupDesc = metadata.desc ? `\n\nğŸ“œ *DescripciÃ³n del grupo:*\n${metadata.desc}` : "";
                  } catch { groupDesc = ""; }
                  await sock.sendMessage(update.id, { text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}${groupDesc}`, mentions: [participant] });
                } else {
                  await sock.sendMessage(update.id, { text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`, mentions: [participant] });
                }
              }
            }
          } else if (update.action === "remove" && despedidasActivo) {
            for (const participant of update.participants) {
              const mention = `@${participant.split("@")[0]}`;
              const mensajeTexto = farewellTexts[Math.floor(Math.random() * farewellTexts.length)];
              const option = Math.random();
              let profilePicUrl;
              try { profilePicUrl = await sock.profilePictureUrl(participant, "image"); }
              catch { profilePicUrl = "https://cdn.dorratz.com/files/1741323171822.jpg"; }
              if (option < 0.5) {
                await sock.sendMessage(update.id, { image: { url: profilePicUrl }, caption: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`, mentions: [participant] });
              } else {
                await sock.sendMessage(update.id, { text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`, mentions: [participant] });
              }
            }
          }
        } catch (error) {
          console.error("Error en el evento group-participants.update:", error);
        }
      });

      // ====== MENSAJES / TODA TU LÃ“GICA (sin tocar) ======
      sock.ev.on("messages.upsert", async (messageUpsert) => {
        try {
          const msg = messageUpsert.messages[0];
          if (!msg) return;

          const chatId = msg.key.remoteJid;
          const isGroup = chatId.endsWith("@g.us");
          const sender = msg.key.participant ? msg.key.participant.replace(/[^0-9]/g, "") : msg.key.remoteJid.replace(/[^0-9]/g, "");
          const botNumber = sock.user.id.split(":")[0];
          const fromMe = msg.key.fromMe || sender === botNumber;
          let messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
          let messageType = Object.keys(msg.message || {})[0];

          const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json")) : {};
          const lista = fs.existsSync("./lista.json") ? JSON.parse(fs.readFileSync("./lista.json")) : [];
          const isAllowedUserLocal = (num) => lista.includes(num);

          console.log(chalk.yellow(`\nğŸ“© Nuevo mensaje recibido`));
          console.log(chalk.green(`ğŸ“¨ De: ${fromMe ? "[TÃº]" : "[Usuario]"} ${chalk.bold(sender)}`));
          console.log(chalk.cyan(`ğŸ’¬ Tipo: ${messageType}`));
          console.log(chalk.cyan(`ğŸ’¬ Mensaje: ${chalk.bold(messageText || "ğŸ“‚ (Mensaje multimedia)")}`));
          console.log(chalk.gray("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"));

          // ---- (todo tu bloque tal cual; no lo recorto) ----
          // Antilink de grupo
          if (isGroup && activos.antilink?.[chatId]) {
            if (messageText.includes("https://chat.whatsapp.com/")) {
              let canBypass = fromMe || isOwner(sender);
              try {
                const metadata = await sock.groupMetadata(chatId);
                const participant = metadata.participants.find((p) => p.id.replace(/[^0-9]/g, "") === sender);
                const isAdmin = participant?.admin === "admin" || participant?.admin === "superadmin";
                if (isAdmin) canBypass = true;
              } catch (e) {
                console.error("Error leyendo metadata (antilink):", e);
                canBypass = true;
              }
              if (!canBypass) {
                await sock.sendMessage(chatId, { delete: msg.key });
                await sock.sendMessage(chatId, {
                  text: `âš ï¸ @${sender} ha enviado un enlace no permitido y ha sido expulsado.`,
                  mentions: [msg.key.participant || msg.key.remoteJid],
                });
                try { await sock.groupParticipantsUpdate(chatId, [msg.key.participant || msg.key.remoteJid], "remove"); }
                catch (e) { console.error("Error al expulsar:", e); }
                return;
              }
            }
          }

          // === ANTIPRIVADO ===
          try {
            const senderId = msg.key.participant || msg.key.remoteJid;
            const isFromMe = msg.key.fromMe;
            const senderClean = senderId.replace(/[^0-9]/g, "");
            const botNumber = sock.user.id.split(":")[0];
            const isOwnerX = global.owner.some(([id]) => id === senderClean);
            const activosPath = "./activos.json";
            const activosX = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath, "utf-8")) : {};
            if (!isGroup && activosX.antiprivado && !isOwnerX && !isFromMe) {
              await sock.updateBlockStatus(senderId, "block");
              await sock.sendMessage("15167096032@s.whatsapp.net", {
                text: `ğŸš« Se bloqueÃ³ automÃ¡ticamente a: wa.me/${senderClean} por escribir en privado al bot.`,
              });
              return;
            }
          } catch (e) { console.error("âŒ Error en lÃ³gica antiprivado:", e); }

          // === ANTIS STICKERS ===
          const stickerMsg = msg.message?.stickerMessage || msg.message?.ephemeralMessage?.message?.stickerMessage;
          if (isGroup && activos.antis?.[chatId] && !fromMe && stickerMsg) {
            const user = msg.key.participant || msg.key.remoteJid;
            const now = Date.now();
            if (!global.antisSpam) global.antisSpam = {};
            if (!global.antisSpam[chatId]) global.antisSpam[chatId] = {};
            if (!global.antisBlackList) global.antisBlackList = {};
            const userData = global.antisSpam[chatId][user] || { count: 0, last: now, warned: false, strikes: 0 };
            const timePassed = now - userData.last;
            if (timePassed > 15000) {
              userData.count = 1;
              userData.last = now;
              userData.warned = false;
              userData.strikes = 0;
              if (global.antisBlackList[chatId]?.includes(user)) {
                global.antisBlackList[chatId] = global.antisBlackList[chatId].filter((u) => u !== user);
              }
            } else {
              userData.count++;
              userData.last = now;
            }
            global.antisSpam[chatId][user] = userData;
            if (userData.count === 5) {
              await sock.sendMessage(chatId, {
                text: `âš ï¸ @${user.split("@")[0]} has enviado 5 stickers. Debes esperar *15 segundos* o si envÃ­as *3 stickers mÃ¡s*, serÃ¡s eliminado automÃ¡ticamente.`,
                mentions: [user],
              });
              userData.warned = true;
              userData.strikes = 0;
              global.antisSpam[chatId][user] = userData;
            }
            if (userData.count > 5 && timePassed < 15000) {
              if (!global.antisBlackList[chatId]) global.antisBlackList[chatId] = [];
              if (!global.antisBlackList[chatId].includes(user)) global.antisBlackList[chatId].push(user);
              await sock.sendMessage(chatId, { delete: { remoteJid: chatId, fromMe: false, id: msg.key.id, participant: user } });
              userData.strikes++;
              global.antisSpam[chatId][user] = userData;
              if (userData.strikes >= 3) {
                await sock.sendMessage(chatId, { text: `âŒ @${user.split("@")[0]} fue eliminado por ignorar las advertencias y abusar de los stickers.`, mentions: [user] });
                await sock.groupParticipantsUpdate(chatId, [user], "remove");
                delete global.antisSpam[chatId][user];
              }
            }
          }

          // === ANTIDELETE (guardar) ===
          try {
            const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
            const activos2 = fs.existsSync("./activos2.json") ? JSON.parse(fs.readFileSync("./activos2.json", "utf-8")) : {};
            const isGroup = chatId.endsWith("@g.us");
            const isAntideleteGroup = activos.antidelete?.[chatId] === true;
            const isAntideletePriv = activos2.antideletepri === true;
            const filePath = isGroup ? "./antidelete.json" : "./antideletepri.json";
            if ((isGroup && isAntideleteGroup) || (!isGroup && isAntideletePriv)) {
              if (!fs.existsSync(filePath)) fs.writeFileSync(filePath, JSON.stringify({}, null, 2));
              const type = Object.keys(msg.message || {})[0];
              const content = msg.message[type];
              const idMsg = msg.key.id;
              const botNumber = sock.user.id.split(":")[0] + "@s.whatsapp.net";
              const senderId = msg.key.participant || (msg.key.fromMe ? botNumber : msg.key.remoteJid);
              if (["imageMessage", "videoMessage", "audioMessage", "documentMessage", "stickerMessage"].includes(type) && content.fileLength > 10 * 1024 * 1024) return;
              const guardado = { chatId, sender: senderId, type, timestamp: Date.now() };
              const saveBase64 = async (mediaType, data) => {
                const stream = await downloadContentFromMessage(data, mediaType);
                let buffer = Buffer.alloc(0);
                for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);
                guardado.media = buffer.toString("base64");
                guardado.mimetype = data.mimetype;
              };
              if (msg.message?.viewOnceMessageV2) {
                const inner = msg.message.viewOnceMessageV2.message;
                const viewType = Object.keys(inner)[0];
                const viewData = inner[viewType];
                const mediaType = viewType.replace("Message", "");
                guardado.type = viewType;
                await saveBase64(mediaType, viewData);
              } else if (["imageMessage", "videoMessage", "audioMessage", "documentMessage", "stickerMessage"].includes(type)) {
                const mediaType = type.replace("Message", "");
                await saveBase64(mediaType, content);
              } else if (type === "conversation" || type === "extendedTextMessage") {
                guardado.text = msg.message.conversation || msg.message.extendedTextMessage?.text || "";
              }
              const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));
              data[idMsg] = guardado;
              fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
            }
          } catch (e) { console.error("âŒ Error al guardar mensaje antidelete:", e); }

          // === MENSAJE ELIMINADO (mostrar) ===
          if (msg.message?.protocolMessage?.type === 0) {
            try {
              const deletedId = msg.message.protocolMessage.key.id;
              const whoDeleted = msg.message.protocolMessage.key.participant || msg.key.participant || msg.key.remoteJid;
              const isGroup = chatId.endsWith("@g.us");
              const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
              const activos2 = fs.existsSync("./activos2.json") ? JSON.parse(fs.readFileSync("./activos2.json", "utf-8")) : {};
              const isAntideleteGroup = activos.antidelete?.[chatId] === true;
              const isAntideletePriv = activos2.antideletepri === true;
              const filePath = isGroup ? "./antidelete.json" : "./antideletepri.json";
              if (!(isGroup ? isAntideleteGroup : isAntideletePriv)) return;
              if (!fs.existsSync(filePath)) return;
              const data = JSON.parse(fs.readFileSync(filePath));
              const deletedData = data[deletedId];
              if (!deletedData) return;
              const senderClean = (deletedData.sender || "").replace(/[^0-9]/g, "");
              const whoDeletedClean = (whoDeleted || "").replace(/[^0-9]/g, "");
              if (senderClean !== whoDeletedClean) return;
              const senderNumber = whoDeletedClean;
              if (isGroup) {
                const meta = await sock.groupMetadata(chatId);
                const isAdmin = meta.participants.find((p) => p.id === `${senderNumber}@s.whatsapp.net`)?.admin;
                if (isAdmin) return;
              }
              if (deletedData.media) {
                const mimetype = deletedData.mimetype || "application/octet-stream";
                const buffer = Buffer.from(deletedData.media, "base64");
                const type = deletedData.type.replace("Message", "");
                const sendOpts = { quoted: msg };
                sendOpts[type] = buffer;
                sendOpts.mimetype = mimetype;
                const mentionTag = [`${senderNumber}@s.whatsapp.net`];
                if (type === "sticker") {
                  const sent = await sock.sendMessage(chatId, sendOpts);
                  await sock.sendMessage(chatId, { text: `ğŸ“Œ El sticker fue eliminado por @${senderNumber}`, mentions: mentionTag, quoted: sent });
                } else if (type === "audio") {
                  const sent = await sock.sendMessage(chatId, sendOpts);
                  await sock.sendMessage(chatId, { text: `ğŸ§ El audio fue eliminado por @${senderNumber}`, mentions: mentionTag, quoted: sent });
                } else {
                  sendOpts.caption = `ğŸ“¦ Mensaje eliminado por @${senderNumber}`;
                  sendOpts.mentions = mentionTag;
                  await sock.sendMessage(chatId, sendOpts, { quoted: msg });
                }
              } else if (deletedData.text) {
                await sock.sendMessage(chatId, {
                  text: `ğŸ“ *Mensaje eliminado:* ${deletedData.text}\nğŸ‘¤ *Usuario:* @${senderNumber}`,
                  mentions: [`${senderNumber}@s.whatsapp.net`],
                }, { quoted: msg });
              }
            } catch (err) { console.error("âŒ Error en lÃ³gica antidelete:", err); }
          }

          // === ChatGPT por grupo (igual) ===
          try {
            const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
            const isGroup = msg.key.remoteJid.endsWith("@g.us");
            const chatId = msg.key.remoteJid;
            const chatgptActivo = activos.chatgpt?.[chatId];
            const fromMe = msg.key.fromMe;
            const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || msg.message?.imageMessage?.caption || msg.message?.videoMessage?.caption || "";
            if (isGroup && chatgptActivo && !fromMe && messageText.length > 0) {
              const encodedText = encodeURIComponent(messageText);
              const sessionID = "1727468410446638";
              const apiUrl = `https://api.neoxr.eu/api/gpt4-session?q=${encodedText}&session=${sessionID}&apikey=russellxz`;
              const res = await axios.get(apiUrl);
              const respuesta = res.data?.data?.message;
              if (respuesta) await sock.sendMessage(chatId, { text: respuesta }, { quoted: msg });
            }
          } catch (e) { console.error("âŒ Error en lÃ³gica ChatGPT por grupo:", e); }

          // === LUMI por grupo (igual) ===
          try {
            const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
            const isGroup = msg.key.remoteJid.endsWith("@g.us");
            const chatId = msg.key.remoteJid;
            const lumiActivo = activos.lumi?.[chatId];
            const fromMe = msg.key.fromMe;
            const textMsg = msg.message?.conversation || msg.message?.extendedTextMessage?.text || msg.message?.imageMessage?.caption || msg.message?.videoMessage?.caption || "";
            if (isGroup && lumiActivo && !fromMe && textMsg.length > 0) {
              const name = "[XEX]";
              const prompt = await getPrompt();
              let result = "";
              try { result = await luminaiQuery(textMsg, name, prompt); result = cleanResponse(result); }
              catch (e) {
                console.error("Error Luminai:", e);
                try { result = await perplexityQuery(textMsg, prompt); }
                catch (e2) { console.error("Error Perplexity:", e2); result = "âŒ No se obtuvo respuesta de los servicios"; }
              }
              if (result) await sock.sendMessage(chatId, { text: result }, { quoted: msg });
            }
          } catch (e) { console.error("âŒ Error en lÃ³gica Lumi AI automÃ¡tica:", e); }

          // === Conteo grupo (igual) ===
          try {
            const conteoPath = path.resolve("./conteo.json");
            if (!fs.existsSync(conteoPath)) fs.writeFileSync(conteoPath, JSON.stringify({}, null, 2));
            const conteoData = JSON.parse(fs.readFileSync(conteoPath, "utf-8"));
            const chatId = msg.key.remoteJid;
            const senderId = msg.key.participant || msg.key.remoteJid;
            const isGroup = chatId.endsWith("@g.us");
            const fromMe = msg.key.fromMe;
            const botNumber = sock.user.id.split(":")[0] + "@s.whatsapp.net";
            if (isGroup) {
              if (!fromMe) {
                if (!conteoData[chatId]) conteoData[chatId] = {};
                if (!conteoData[chatId][senderId]) conteoData[chatId][senderId] = 0;
                conteoData[chatId][senderId] += 1;
              }
              if (fromMe) {
                if (!conteoData[chatId]) conteoData[chatId] = {};
                if (!conteoData[chatId][botNumber]) conteoData[chatId][botNumber] = 0;
                conteoData[chatId][botNumber] += 1;
              }
              fs.writeFileSync(conteoPath, JSON.stringify(conteoData, null, 2));
            }
          } catch (e) { console.error("âŒ Error en contador de mensajes:", e); }

          // === Comandos desde sticker (igual) ===
          try {
            const jsonPath = "./comandos.json";
            if (!fs.existsSync(jsonPath)) return;
            if (msg.message?.stickerMessage) {
              const fileSha = msg.message.stickerMessage.fileSha256?.toString("base64");
              const comandosData = JSON.parse(fs.readFileSync(jsonPath, "utf-8"));
              const cmd = comandosData[fileSha];
              if (!cmd) return;
              const messageText = cmd.toLowerCase().trim();
              const parts = messageText.split(" ");
              const mainCommand = parts[0];
              const args = parts.slice(1);
              const chatId = msg.key.remoteJid;
              const sender = msg.key.participant || msg.key.remoteJid;
              const contextInfo = msg.message?.stickerMessage?.contextInfo || {};
              const quotedMsg = contextInfo.quotedMessage || null;
              const quotedParticipant = contextInfo.participant || null;
              const fakeMessage = {
                ...msg,
                message: { extendedTextMessage: { text: messageText, contextInfo: { quotedMessage: quotedMsg, participant: quotedParticipant, stanzaId: contextInfo.stanzaId || "", remoteJid: contextInfo.remoteJid || chatId } } },
                body: messageText, text: messageText, command: mainCommand,
                key: { ...msg.key, fromMe: false, participant: sender }
              };
              const { handleCommand } = require("./main");
              const isPluginCommand = global.plugins?.some((p) => p.command?.includes?.(mainCommand));
              await handleCommand(sock, fakeMessage, mainCommand, args, sender);
              if (isPluginCommand) {
                for (const plugin of global.plugins) {
                  if (plugin.command?.includes(mainCommand)) {
                    if (typeof plugin.run === "function") {
                      await plugin.run({ msg: fakeMessage, conn: sock, args, command: mainCommand });
                      break;
                    }
                  }
                }
              }
            }
          } catch (err) { console.error("âŒ Error al ejecutar comando desde sticker:", err); }

          // === Respuesta por palabra clave (igual) ===
          try {
            const actPath = path.resolve("./activos.json");
            const modoAdminsOn = isGroup && fs.existsSync(actPath) && JSON.parse(fs.readFileSync(actPath, "utf-8")).modoAdmins?.[chatId] === true;
            const guarPath = path.resolve("./guar.json");
            if (fs.existsSync(guarPath)) {
              const guarData = JSON.parse(fs.readFileSync(guarPath, "utf-8"));
              const cleanText = messageText.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\w]/g, "");
              for (const key of Object.keys(guarData)) {
                const cleanKey = key.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\w]/g, "");
                if (cleanText === cleanKey) {
                  const item = guarData[key];
                  const buffer = Buffer.from(item.buffer, "base64");
                  const payload = {};
                  switch (item.extension) {
                    case "jpg":
                    case "jpeg":
                    case "png": payload.image = buffer; break;
                    case "mp4": payload.video = buffer; break;
                    case "mp3":
                    case "ogg":
                    case "opus": payload.audio = buffer; payload.mimetype = item.mimetype || "audio/mpeg"; payload.ptt = false; break;
                    case "webp": payload.sticker = buffer; break;
                    default: payload.document = buffer; payload.mimetype = item.mimetype || "application/octet-stream"; payload.fileName = `archivo.${item.extension}`; break;
                  }
                  await sock.sendMessage(chatId, payload, { quoted: msg });
                  return;
                }
              }
            }
          } catch (e) { console.error("âŒ Error en lÃ³gica de palabra clave:", e); }

          // === Muteados (igual) ===
          try {
            const chatId = msg.key.remoteJid;
            const isGroup = chatId.endsWith("@g.us");
            if (isGroup) {
              const senderId = msg.key.participant || msg.key.remoteJid;
              const mutePath = "./mute.json";
              const muteData = fs.existsSync(mutePath) ? JSON.parse(fs.readFileSync(mutePath)) : {};
              const muteList = muteData[chatId] || [];
              if (muteList.includes(senderId)) {
                global._muteCounter = global._muteCounter || {};
                const key = `${chatId}:${senderId}`;
                global._muteCounter[key] = (global._muteCounter[key] || 0) + 1;
                const count = global._muteCounter[key];
                if (count === 8) await sock.sendMessage(chatId, { text: `âš ï¸ @${senderId.split("@")[0]} estÃ¡s muteado.\nSigue enviando mensajes y podrÃ­as ser eliminado.`, mentions: [senderId] });
                if (count === 13) await sock.sendMessage(chatId, { text: `â›” @${senderId.split("@")[0]} estÃ¡s al lÃ­mite.\nSi envÃ­as *otro mensaje*, serÃ¡s eliminado del grupo.`, mentions: [senderId] });
                if (count >= 15) {
                  const metadata = await sock.groupMetadata(chatId);
                  const user = metadata.participants.find((p) => p.id === senderId);
                  const isAdmin = user?.admin === "admin" || user?.admin === "superadmin";
                  if (!isAdmin) {
                    await sock.groupParticipantsUpdate(chatId, [senderId], "remove");
                    await sock.sendMessage(chatId, { text: `âŒ @${senderId.split("@")[0]} fue eliminado por ignorar el mute.`, mentions: [senderId] });
                    delete global._muteCounter[key];
                  } else {
                    await sock.sendMessage(chatId, { text: `ğŸ”‡ @${senderId.split("@")[0]} es administrador y no se puede eliminar.`, mentions: [senderId] });
                  }
                }
                await sock.sendMessage(chatId, { delete: { remoteJid: chatId, fromMe: false, id: msg.key.id, participant: senderId } });
                return;
              }
            }
          } catch (err) { console.error("âŒ Error en lÃ³gica de muteo:", err); }

          // === Baneados (igual) ===
          try {
            const banPath = path.resolve("./ban.json");
            const banData = fs.existsSync(banPath) ? JSON.parse(fs.readFileSync(banPath)) : {};
            const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
            if (!messageText.startsWith(global.prefix)) return;
            const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();
            const senderId = msg.key.participant || msg.key.remoteJid;
            const senderClean = senderId.replace(/[^0-9]/g, "");
            const senderLID = senderId;
            const senderClassic = `${senderClean}@s.whatsapp.net`;
            const isFromMe = msg.key.fromMe;
            const isOwnerX = global.owner.some(([id]) => id === senderClean);
            const groupBanList = banData[chatId] || [];
            if ((groupBanList.includes(senderClassic) || groupBanList.includes(senderLID)) && !isOwnerX && !isFromMe) {
              const frases = [
                "ğŸš« @usuario estÃ¡s baneado por pendejo. Â¡Abusaste demasiado del bot!",
                "âŒ Lo siento @usuario, pero tÃº ya no puedes usarme. Aprende a comportarte.",
                "ğŸ”’ No tienes permiso @usuario. Fuiste baneado por molestar mucho.",
                "ğŸ‘ Â¡Bloqueado! @usuario abusaste del sistema y ahora no puedes usarme.",
                "ğŸ˜¤ Quisiste usarme pero estÃ¡s baneado, @usuario. Vuelve en otra vida.",
              ];
              const texto = frases[Math.floor(Math.random() * frases.length)].replace("@usuario", `@${senderClean}`);
              await sock.sendMessage(chatId, { text: texto, mentions: [senderId] }, { quoted: msg });
              return;
            }
          } catch (e) { console.error("âŒ Error procesando bloqueo de usuarios baneados:", e); }

          // === Arabes en privado (igual) ===
          try {
            const chatId = msg.key.remoteJid;
            const isGroup = chatId.endsWith("@g.us");
            if (!isGroup) {
              const sender = msg.key.participant || msg.key.remoteJid;
              const senderNum = sender.replace(/[^0-9]/g, "");
              const disallowedPrefixes = ["20","212","213","216","218","222","249","252","253","269","962","963","964","965","966","967","968","970","971","972","973","974","975","976","977","980","981","982","983","984","985","986","987","988","989"];
              const esArabe = disallowedPrefixes.some((pref) => senderNum.startsWith(pref));
              if (esArabe) {
                await sock.updateBlockStatus(sender, "block");
                const myJid = sock.user.id.split(":")[0] + "@s.whatsapp.net";
                await sock.sendMessage(myJid, { text: `ğŸ“› *NÃºmero Ã¡rabe bloqueado automÃ¡ticamente:*\n\nğŸ§¿ NÃºmero: wa.me/${senderNum}\nğŸ“© IntentÃ³ escribir al bot en privado.\n\nâœ… El nÃºmero fue bloqueado.` });
                await sock.sendMessage(sender, { text: "ğŸš« Este bot no acepta mensajes privados de nÃºmeros Ã¡rabes. Has sido bloqueado automÃ¡ticamente." });
                return;
              }
            }
          } catch (e) { console.error("âŒ Error en bloqueo automÃ¡tico de Ã¡rabes:", e); }

          // ğŸ” Modo Privado y Admins por grupo (tu lÃ³gica intacta)
          if (activos.modoPrivado) {
            if (isGroup) {
              if (!fromMe && !isOwner(sender)) return;
            } else {
              if (!fromMe && !isOwner(sender) && !isAllowedUserLocal(sender)) return;
            }
          } else {
            if (isGroup && activos.modoAdmins?.[chatId]) {
              try {
                const metadata = await sock.groupMetadata(chatId);
                const participant = metadata.participants.find((p) => p.id.includes(sender));
                const isAdmin = participant?.admin === "admin" || participant?.admin === "superadmin";
                if (!isAdmin && !isOwner(sender) && !fromMe) return;
              } catch (e) {
                console.error("Error leyendo metadata:", e);
                return;
              }
            }
            if (!isGroup && !fromMe && !isOwner(sender) && !isAllowedUserLocal(sender)) return;
          }

          // Bloqueo si grupo apagado
          try {
            const activosPath = "./activos.json";
            const activos = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath, "utf-8")) : {};
            const isApagado = activos.apagado?.[chatId] === true;
            const senderClean = sender.replace(/[^0-9]/g, "");
            const isOwnerX = global.owner.some(([id]) => id === senderClean);
            if (isGroup && isApagado && !isOwnerX) return;
          } catch (e) { console.error("âŒ Error en lÃ³gica de bloqueo por apagado:", e); }

          // Bloqueo comandos RPG si inactivo
          try {
            const comandosRpg = ["rpg","nivel","picar","minar","minar2","work","crime","robar","cofre","claim","batallauser","hospital","hosp","luchar","poder","volar","otromundo","otrouniverso","mododios","mododiablo","podermaximo","enemigos","nivelper","per","bolasdeldragon","vender","quitarventa","batallaanime","comprar","tiendaper","alaventa","verper","daragua","darcariÃ±o","darcomida","presumir","cazar","entrenar","pasear","supermascota","mascota","curar","nivelmascota","batallamascota","compra","tiendamascotas","vermascotas","addmascota","addper","deleteuser","deleteper","deletemascota","totalper","tran","transferir","dame","dep","bal","saldo","retirar","depositar","delrpg","topuser","topmascotas","topper"];
            const activosPath = path.resolve("./activos.json");
            const activos = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath)) : {};
            const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
            if (!messageText.startsWith(global.prefix)) return;
            const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();
            const rpgActivo = activos.rpgazura?.[chatId];
            if (comandosRpg.includes(commandOnly) && !rpgActivo) {
              const mensajesBloqueo = [
                "ğŸš« Este comando RPG estÃ¡ desactivado en este grupo. Usa .rpgazura on o off.",
                "ğŸ›‘ El mundo RPG estÃ¡ apagado. Usa .rpgazura on o off.",
                "âŒ Comandos RPG no disponibles. Usa .rpgazura on o off.",
                "ğŸš· Sistema RPG desactivado. Usa .rpgazura on o off.",
              ];
              const textoBloqueo = mensajesBloqueo[Math.floor(Math.random() * mensajesBloqueo.length)];
              await sock.sendMessage(chatId, { text: textoBloqueo }, { quoted: msg });
              return;
            }
          } catch (e) { console.error("âŒ Error procesando bloqueo de comandos RPG:", e); }

          // Bloqueo +18 si inactivo
          try {
            const comandosHot = ["videoxxx","pornololi","nsfwneko","nsfwwaifu","waifu","neko"];
            const activosPath = path.resolve("./activos.json");
            const activos = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath)) : {};
            const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
            if (!messageText.startsWith(global.prefix)) return;
            const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();
            const senderClean = sender.replace(/[^0-9]/g, "");
            const isOwnerX = global.owner.some(([id]) => id === senderClean);
            const isFromMe = msg.key.fromMe;
            const calienteActivo = activos.modocaliente?.[chatId];
            if (comandosHot.includes(commandOnly) && !calienteActivo && !isOwnerX && !isFromMe) {
              const mensajesBloqueo = [
                "ğŸš« Velo pajiso, este comando +18 estÃ¡ desactivado. PÃ­dele a un admin que lo active con .modocaliente on o off.",
                "âŒ QuÃ© desesperaciÃ³n, aguÃ¡ntese. El modo caliente no estÃ¡ activado con .modocaliente on o off.",
                "ğŸ›‘ Este comando +18 estÃ¡ apagado. Primero active el modo caliente con .modocaliente on o off.",
                "ğŸš· Caliente frustrado detectado. El modo +18 estÃ¡ desactivado en este grupo.",
              ];
              const textoBloqueo = mensajesBloqueo[Math.floor(Math.random() * mensajesBloqueo.length)];
              await sock.sendMessage(chatId, { text: textoBloqueo }, { quoted: msg });
              return;
            }
          } catch (e) { console.error("âŒ Error procesando bloqueo de modo caliente:", e); }

          // Restringidos por grupo (igual)
          try {
            const rePath = path.resolve("./re.json");
            const cachePath = path.resolve("./restriccion_cache.json");
            if (!fs.existsSync(cachePath)) fs.writeFileSync(cachePath, JSON.stringify({}, null, 2));
            const reData = fs.existsSync(rePath) ? JSON.parse(fs.readFileSync(rePath)) : {};
            const cacheData = JSON.parse(fs.readFileSync(cachePath));
            const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();
            const comandosRestringidos = reData[chatId] || [];
            const senderClean = sender.replace(/[^0-9]/g, "");
            const isOwnerX = global.owner.some(([id]) => id === senderClean);
            const isFromMe = msg.key.fromMe;
            const key = `${chatId}:${senderClean}:${commandOnly}`;
            if (!comandosRestringidos.includes(commandOnly) && cacheData[key]) {
              delete cacheData[key];
              fs.writeFileSync(cachePath, JSON.stringify(cacheData, null, 2));
              return;
            }
            if (comandosRestringidos.includes(commandOnly) && !isOwnerX && !isFromMe) {
              cacheData[key] = (cacheData[key] || 0) + 1;
              const replyOptions = { quoted: msg, mentions: [sender + "@s.whatsapp.net"] };
              if (cacheData[key] < 5) {
                await sock.sendMessage(chatId, { text: `ğŸš« *Este comando estÃ¡ restringido en este grupo.*\nâš ï¸ Solo el owner o el bot pueden usarlo.` }, replyOptions);
              } else if (cacheData[key] === 5) {
                await sock.sendMessage(chatId, { text: `âŒ *Has intentado usar este comando demasiadas veces.*\nğŸ¤– Ahora el bot te ignorarÃ¡ respecto a *${commandOnly}*.` }, replyOptions);
              }
              fs.writeFileSync(cachePath, JSON.stringify(cacheData, null, 2));
              return;
            }
          } catch (e) { console.error("âŒ Error procesando comando restringido:", e); }

          // === Dispatcher de comandos (igual) ===
          if (messageText.startsWith(global.prefix)) {
            const command = messageText.slice(global.prefix.length).trim().split(" ")[0];
            const args = messageText.slice(global.prefix.length + command.length).trim().split(" ");
            handleCommand(sock, msg, command, args, sender);
          }
        } catch (error) {
          console.error("âŒ Error en messages.upsert:", error);
        }
      });

      // ====== conexiÃ³n ======
      sock.ev.on("connection.update", async (update) => {
        const { connection } = update;
        if (connection === "connecting") {
          console.log(chalk.blue("ğŸ”„ Conectando a WhatsApp..."));
        } else if (connection === "open") {
          console.log(chalk.green("âœ… Â¡ConexiÃ³n establecida con Ã©xito!"));
          const restarterFile = "./lastRestarter.json";
          if (fs.existsSync(restarterFile)) {
            try {
              const data = JSON.parse(fs.readFileSync(restarterFile, "utf-8"));
              if (data.chatId) {
                await sock.sendMessage(data.chatId, { text: "âœ… *El bot estÃ¡ en lÃ­nea nuevamente tras el reinicio.* ğŸš€" });
                console.log(chalk.green("ğŸ“¢ NotificaciÃ³n enviada al chat del reinicio."));
                fs.unlinkSync(restarterFile);
              }
            } catch (error) { console.error("âŒ Error al procesar lastRestarter.json:", error); }
          }
        } else if (connection === "close") {
          console.log(chalk.red("âŒ ConexiÃ³n cerrada. Intentando reconectar en 5 segundos..."));
          setTimeout(startBot, 5000);
        }
      });

      sock.ev.on("creds.update", saveCreds);

      process.on("uncaughtException", (err) => console.error(chalk.red("âš ï¸ Error no manejado:"), err));
      process.on("unhandledRejection", (reason, promise) => console.error(chalk.red("ğŸš¨ Promesa rechazada sin manejar:"), promise, "razÃ³n:", reason));
      // ---------- FIN BLOQUES ----------
    } catch (error) {
      console.error(chalk.red("âŒ Error en la conexiÃ³n:"), error);
      console.log(chalk.blue("ğŸ”„ Reiniciando en 5 segundos..."));
      setTimeout(startBot, 5000);
    }
  }

  await startBot();
})();
